// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: auction.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAuction = `-- name: CreateAuction :one
INSERT INTO auctions (
  product_id,
  user_id,
  start_time,
  end_time,
  starting_price,
  current_price,
  status,
  winner_id
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, product_id, user_id, start_time, end_time, starting_price, current_price, status, winner_id, updated_at, created_at
`

type CreateAuctionParams struct {
	ProductID     string      `json:"product_id"`
	UserID        uuid.UUID   `json:"user_id"`
	StartTime     time.Time   `json:"start_time"`
	EndTime       time.Time   `json:"end_time"`
	StartingPrice float64     `json:"starting_price"`
	CurrentPrice  float64     `json:"current_price"`
	Status        string      `json:"status"`
	WinnerID      pgtype.UUID `json:"winner_id"`
}

func (q *Queries) CreateAuction(ctx context.Context, arg CreateAuctionParams) (Auction, error) {
	row := q.db.QueryRow(ctx, createAuction,
		arg.ProductID,
		arg.UserID,
		arg.StartTime,
		arg.EndTime,
		arg.StartingPrice,
		arg.CurrentPrice,
		arg.Status,
		arg.WinnerID,
	)
	var i Auction
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UserID,
		&i.StartTime,
		&i.EndTime,
		&i.StartingPrice,
		&i.CurrentPrice,
		&i.Status,
		&i.WinnerID,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getAllAuctions = `-- name: GetAllAuctions :many
SELECT id, product_id, user_id, start_time, end_time, starting_price, current_price, status, winner_id, updated_at, created_at FROM auctions
`

func (q *Queries) GetAllAuctions(ctx context.Context) ([]Auction, error) {
	rows, err := q.db.Query(ctx, getAllAuctions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Auction
	for rows.Next() {
		var i Auction
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.UserID,
			&i.StartTime,
			&i.EndTime,
			&i.StartingPrice,
			&i.CurrentPrice,
			&i.Status,
			&i.WinnerID,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuction = `-- name: GetAuction :one
SELECT id, product_id, user_id, start_time, end_time, starting_price, current_price, status, winner_id, updated_at, created_at FROM auctions
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAuction(ctx context.Context, id uuid.UUID) (Auction, error) {
	row := q.db.QueryRow(ctx, getAuction, id)
	var i Auction
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UserID,
		&i.StartTime,
		&i.EndTime,
		&i.StartingPrice,
		&i.CurrentPrice,
		&i.Status,
		&i.WinnerID,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getAuctionForUpdate = `-- name: GetAuctionForUpdate :one
SELECT id, product_id, user_id, start_time, end_time, starting_price, current_price, status, winner_id, updated_at, created_at FROM auctions
WHERE id = $1
FOR NO KEY UPDATE
`

func (q *Queries) GetAuctionForUpdate(ctx context.Context, id uuid.UUID) (Auction, error) {
	row := q.db.QueryRow(ctx, getAuctionForUpdate, id)
	var i Auction
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UserID,
		&i.StartTime,
		&i.EndTime,
		&i.StartingPrice,
		&i.CurrentPrice,
		&i.Status,
		&i.WinnerID,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listAuctions = `-- name: ListAuctions :many
SELECT id, product_id, user_id, start_time, end_time, starting_price, current_price, status, winner_id, updated_at, created_at FROM auctions
ORDER BY  id
LIMIT $1
OFFSET $2
`

type ListAuctionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListAuctions(ctx context.Context, arg ListAuctionsParams) ([]Auction, error) {
	rows, err := q.db.Query(ctx, listAuctions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Auction
	for rows.Next() {
		var i Auction
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.UserID,
			&i.StartTime,
			&i.EndTime,
			&i.StartingPrice,
			&i.CurrentPrice,
			&i.Status,
			&i.WinnerID,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAuction = `-- name: UpdateAuction :one
UPDATE auctions
set end_time = COALESCE($1, end_time),
  current_price = COALESCE($2, current_price),
  status = COALESCE($3, status)
WHERE id = $4
RETURNING id, product_id, user_id, start_time, end_time, starting_price, current_price, status, winner_id, updated_at, created_at
`

type UpdateAuctionParams struct {
	EndTime      pgtype.Timestamptz `json:"end_time"`
	CurrentPrice pgtype.Float8      `json:"current_price"`
	Status       pgtype.Text        `json:"status"`
	ID           uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateAuction(ctx context.Context, arg UpdateAuctionParams) (Auction, error) {
	row := q.db.QueryRow(ctx, updateAuction,
		arg.EndTime,
		arg.CurrentPrice,
		arg.Status,
		arg.ID,
	)
	var i Auction
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.UserID,
		&i.StartTime,
		&i.EndTime,
		&i.StartingPrice,
		&i.CurrentPrice,
		&i.Status,
		&i.WinnerID,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
